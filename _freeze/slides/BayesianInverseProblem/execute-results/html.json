{
  "hash": "d6621b9d123ccde8635ba1b00200d04b",
  "result": {
    "markdown": "---\ntitle: \"Bayesian inverse problem practice\"\nformat: \n    revealjs:\n      mainfont: Lato\n      smaller: true\n---\n\n\n# Toy example: logistic growth\n\n## E. coli\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nlibrary(tidyverse)\n```\n:::\n\n\n\nE. coli grows in a petri dish according to the logistic growth equation,\n\n\n$$\n\\frac{dP}{dt} = rP( 1 - \\frac{P}{K})\n$$\n\n\nwhere $P(t)$ is the population size at time $t$, $r$ is the per capita growth rate, and $K$ is the carrying capacity of the dish.\n\nThis equation can be solved analytically (which is what makes this a toy example), \n\n\n$$\nP(t) = \\frac{K}{1 + Ae^{-rt}}\n$$\n\nwhere $A = \\frac{K - P_0}{P_0}$ and $P_0$ is the initial population size at time 0.\n\n## Data\n\nBacterial populations are measured in CFU (colony forming units). At time $t = 0$, 1 colony forming unit was placed into a dish.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npopulationFunction = function(K, r, t) {\n  P0 = 1\n  A = (K - P0) / P0\n  round(K / (1 + (A * exp(-r * t))))\n}\n```\n:::\n\n\nIn the past, CFU are counted manually in a small pipetted sample and then the CFU per unit volume are multiplied by the total volume in the dish to estimate the total population size of bacteria at a given time $t$. \n\nA new machine has been created to replace this mundane task by automating the counting of CFUs in a sample. The machine counts the bacteria in the dish every fifteen minutes since the start of the experiment. Data are provided below.\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ny = read_csv(\"https://sta360-fa24.github.io/data/E_coli.csv\")\nglimpse(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 24\nColumns: 2\n$ P    <dbl> 2, 3, 5, 8, 13, 22, 37, 64, 103, 186, 318, 542, 843, 1490, 2283, …\n$ time <dbl> 15, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165, 180, 195, 210, 2…\n```\n:::\n:::\n\n\nNote: time is in minutes.\n\n## Model\n\nWe know $P_0 = 1$. Let $\\theta = \\{r, K\\}$\n\nWe assume the machine has some normal measurement error that is proportional to the size of the population. Thus the data generative model is given by\n\n\n$$\nP(t) |r,K \\sim N(f(\\theta, t),\\sigma^2 f(\\theta, t))\n$$\n\nwhere $f(\\theta, t)$ is computed by `populationFunction` on the previous slide.\n\n\n## Exercise\n\nYour task is to determine the measurment error of the machine $\\sigma^2$.\n\nIt is well known that E coli takes about 20 minutes in laboratory conditions to double in size. Given this, we'd expect $r$ to be about $\\frac{\\log(2)}{20}$.\n\nFurthermore, we know the carrying capacity of the petri dish is at least $10^8$ CFU.\n\n1. Identify each unknown.\n\n2. Use the information above to develop reasonable priors over each unknown.\n\n3. Write pseudo-code of an MCMC sampler to make inference about the parameters.\n\n4. (optional) Implement your sampler.\n\n## Solution\n\nThe unknowns are $r, K, \\sigma^2$.\n\nMaybe we think it takes somewhere between 15 minutes and 25 minutes for the population size to double under our lab conditions. Some plausible prior choices are\n\n\n$$\n\\begin{aligned}\nr &\\sim \\text{Uniform}(\\log(2)/25, \\log(2)/15)\\\\\nK &\\propto 1 \\text{ if } K > 10^8\\\\\\\n\\sigma^2 &\\sim \\text{inverse-gamma}(1, 1)\n\\end{aligned}\n$$\n\n\nPseudocode:\n\n```\ninitialize r, K, sigma^2 \nS = large number\nfor (i in 1:S) {\n - sample r* ~ cnorm(1, r_s, .01, a = log(2)/25, b = log(2)/15)\n - compute MH ratio: [posterior(r*)/posterior(r_s)] * [J(r_s | r*)/J(r* | r_s)]\n - accept/reject\n - sample K* ~ cnorm(1, K_s, 1E5, a = 1E8)\n - compute MH ratio like above and accept/reject\n - sample sigma^2* ~ cnorm(1, sigma^2_s, .1, a = 0)\n - compute MH ratio like above and accept/reject\n}\n```\n\n\n<!-- ## Solution MCMC -->\n\n<!-- ```{r} -->\n<!-- #| eval: false -->\n<!-- library(truncnorm) -->\n<!-- set.seed(360) -->\n\n<!-- rcnorm<-function(n, mean=0, sd=1, a=-Inf, b=Inf){ -->\n<!--   u = runif(n, pnorm((a - mean) / sd), pnorm((b - mean) / sd)) -->\n<!--   mean + (sd * qnorm(u)) -->\n<!-- } -->\n\n<!-- dtruncnormL = function(x, a = -Inf, b = Inf, mean, sd) { -->\n<!--   log(dtruncnorm(x, a=a, b=b, mean = mean, sd = sd)) -->\n<!-- } -->\n\n<!-- # starting points -->\n<!-- K_s =  1E9 -->\n<!-- K = NULL -->\n\n<!-- r0_s = runif(1, min = log(2)/30, max = log(2)/10) -->\n<!-- r0 = NULL -->\n\n<!-- sigma2_s = 1 / rgamma(1, 1, 1) -->\n<!-- sigma2 = NULL -->\n\n<!-- S = 100000 # number of iterations -->\n\n<!-- delta_r = .02 # proposal variance -->\n<!-- accept_r = 0 # keep track of acceptance rate -->\n\n<!-- delta_sigma = 0.05 -->\n<!-- accept_sigma = 0 -->\n\n<!-- accept_k = 0 -->\n\n<!-- getLogPosterior = function(K, r, sigma2) { -->\n<!--   sigma = sqrt(sigma2) -->\n<!--   mu = populationFunction(K = K, r = r, t = y$time) -->\n<!--   if (K < 10^8) { -->\n<!--     return(-Inf) -->\n<!--   } -->\n<!--   if(r < log(2)/10) { -->\n<!--     return(-Inf) -->\n<!--   } -->\n<!--   if(r > log(2)/30) { -->\n<!--     return(-Inf) -->\n<!--   } -->\n<!--   else { -->\n<!--   return(sum(dnorm(y$P, mu, sd = sqrt(mu)*sigma), log = TRUE) +  -->\n<!--            dgamma(1 / sigma2, 1, 1, log = TRUE)) -->\n<!--   } -->\n<!-- } -->\n\n<!-- for (s in 1:S) { -->\n<!--   # log everything for numerical stability # -->\n\n<!--   ## propose K -->\n<!--   K_proposal = rcnorm(1, mean = K_s, sd = 1E5, a = 1E8) -->\n<!--   log.r = getLogPosterior(K = K_proposal, r = r0_s, sigma2 = sigma2_s) +  -->\n<!--     dtruncnormL(K_s,  -->\n<!--                 a=1E8,  -->\n<!--                 mean = K_proposal, sd = 1E5) - -->\n<!--     getLogPosterior(K = K_s, r = r0_s, sigma2 = sigma2_s) -  -->\n<!--     dtruncnormL(K_proposal,  -->\n<!--                 a=1E8,  -->\n<!--                 mean = K_s, sd = 1E5) -->\n\n<!--    if(log(runif(1)) < log.r)  { -->\n<!--     K_s = K_proposal -->\n<!--     accept_k = accept_k + 1  -->\n<!--    } -->\n\n<!--   ## propose r -->\n\n<!--   r0_proposal = rcnorm(1, r0_s, delta_r, a = log(2)/30, b = log(2)/10) -->\n\n<!--   log.r = getLogPosterior(K = K_s, r = r0_proposal, sigma2 = sigma2_s) - -->\n<!--     getLogPosterior(K = K_s, r = r0_s, sigma2 = sigma2_s) -->\n\n<!--    if(log(runif(1)) < log.r)  { -->\n<!--     r0_s = r0_proposal -->\n<!--     accept_r = accept_r + 1 -->\n<!--    } -->\n\n<!--   ## propose sigma2 -->\n\n<!--   sigma2_proposal = rnorm(1, sigma2_s, delta_sigma) -->\n\n<!--   log.r = getLogPosterior(K = K_s, r = r0_s, sigma2 = sigma2_proposal) - -->\n<!--     getLogPosterior(K = K_s, r = r0_s, sigma2 = sigma2_s) -->\n\n<!--    if(log(runif(1)) < log.r)  { -->\n<!--     sigma2_s = sigma2_proposal -->\n<!--     accept_sigma = accept_sigma + 1 -->\n<!--    } -->\n\n<!--   if(s %% 10 == 0) { -->\n<!--   r0 = c(r0, r0_s) -->\n<!--   K = c(K, K_s) -->\n<!--   sigma2 = c(sigma2, sigma2_s) -->\n<!--   } -->\n<!-- } -->\n<!-- ``` -->\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    function fireSlideChanged(previousSlide, currentSlide) {\n\n      // dispatch for htmlwidgets\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for reveal\n    if (window.Reveal) {\n      window.Reveal.addEventListener(\"slidechanged\", function(event) {\n        fireSlideChanged(event.previousSlide, event.currentSlide);\n      });\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}